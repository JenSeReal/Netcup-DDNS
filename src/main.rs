mod api;
mod errors;
mod serialization;

use std::{env, time::Duration};

use dotenv::dotenv;
use error_stack::{IntoReport, Report, ResultExt};
use log::info;
use structopt::StructOpt;

use api::{
  login::{LoginRequest, LoginResponse},
  logout::LogoutResponse,
};
use tokio::time::sleep;

use crate::{api::logout::LogoutRequest, errors::Errors};

#[derive(Debug, StructOpt)]
#[structopt(
  name = "Netcup updater",
  about = "Updates one DNS record in Netcup via the API."
)]
pub(crate) struct Cli {
  #[structopt(
    short,
    long,
    env = "CUSTOMER_NUMBER",
    help = "The customer number which identifies your Netcup account."
  )]
  customer_number: u32,
  #[structopt(
    short = "k",
    long,
    env = "API_KEY",
    help = "The API key generated by Netcup in the CCP."
  )]
  api_key: String,
  #[structopt(
    short = "p",
    long,
    env = "API_PASSWORD",
    help = "The API password generated by Netcup in the CCP."
  )]
  api_password: String,
}

#[tokio::main]
async fn main() -> error_stack::Result<(), Errors> {
  env::set_var("RUST_LOG", "debug");
  dotenv().report().change_context(Errors::LoadingEnvFile)?;
  env_logger::init();

  let cli = Cli::from_args();
  let client = reqwest::Client::new();

  let login_response: LoginResponse = api::request(
    &client,
    &LoginRequest::new(cli.customer_number, &cli.api_key, &cli.api_password),
  )
  .await
  .change_context(Errors::Login)?;

  info!("Login successful");

  sleep(Duration::from_secs(2)).await;

  let api_session_id = login_response
    .api_session_id()
    .ok_or_else(|| Report::new(Errors::RetrieveAPISesionId))?;

  api::request::<LogoutRequest, LogoutResponse>(
    &client,
    &LogoutRequest::new(cli.customer_number, &cli.api_key, &api_session_id),
  )
  .await
  .change_context(Errors::Logout)?;

  info!("Logout successful");

  Ok(())
}
